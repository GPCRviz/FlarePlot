#!/usr/bin/env python3

"""
Takes a list of atomic contacts as input and generates a json representing a temporal flare
which can be visualized using flareplots.

By default, the labels on the plot will reflect the residue identifier. Optionally, a
"flare-label" file can be supplied which indicates how residue identifiers should be
translated to flare-plot labels. The flare-label file is a tab-separated text-file where
each line has one field that indicates a colon-separated residue identifier and one field
that indicates the corresponding flareplot label. Dots in the flareplot labels can be used
to group and organize labels. A valid flare-label file would look like this:
    A:ARG:4 Root.1.1x30
    A:LYS:5 Root.1.1x31
    ...
    A:PRO:45 Root.2.2x36
    A:MET:46 Root.2.2x37
    ...
The flare-label file can also act as a filter, as interactions between residues that are not
included in the file will be excluded from the plot. For convenience it's not necessary to
include the second column if the label file is just used as a filter. A third column can
be supplied indicating a color in hex-format (e.g. #FF0000).
"""


def main():
    # Parse command line arguments
    import argparse as ap
    parser = ap.ArgumentParser(description=__doc__)
    optional = parser._action_groups.pop()
    required = parser.add_argument_group('required arguments')
    parser._action_groups.append(optional)  # added this line

    required.add_argument('--input',
                          required=True,
                          type=ap.FileType('r'),
                          help='A multi-frame contact-file generated by dynamic_contact.py')
    required.add_argument('--output',
                          required=True,
                          type=ap.FileType('w'),
                          help='The json file to write flare to')

    optional.add_argument('--pdb',
                          required=False,
                          help='PDB file used for full sequence and secondary structure')
    optional.add_argument('--itype',
                          required=False,
                          default="hbss",
                          type=str,
                          help='Interaction types to include (comma separated list)')
    optional.add_argument('--flarelabels',
                          required=False,
                          default=None,
                          type=ap.FileType('r'),
                          help='Flare-label file')

    args = parser.parse_args()

    # Read contacts and generate graph
    contacts = parse_contacts(args.input)
    labels = parse_flarelabels(args.flarelabels)
    graph = create_graph(contacts, labels)

    # Convert string to pretty printed JSON
    import json
    pretty_json = json.dumps(graph, indent=2)

    # "frames" entries can contain a lot of digits so put those on a single line
    import re
    pretty_json = re.sub(r"(?<=\d,)\n *|(?<=\[)\n *(?=\d)|(?<=\d)\n *(?=\])", "", pretty_json, flags=re.MULTILINE)

    # Write to output file
    args.output.write(pretty_json)
    args.output.close()
    #print(pretty_json)


def parse_contacts(contact_file):
    """
    Parses the contact file and returns it a list of atomic contacts. Atom strings are
    converted to tuples by splitting on ":".

    Parameters
    ----------
    contact_file: file
        Contact-file generated by dynamic_contacts.py

    Returns
    -------
    list of tuples
        e.g. [("0", "hbbb", ("A", "ARG", "4", "H"), ("A", "PHE", "22", "O")), (..) ]
    """
    def parse_atom(atom_str):
        atom_tokens = atom_str.split(":")
        return tuple(atom_tokens)

    ret = []
    for line in contact_file:
        line = line.strip()
        if not line:
            continue  # Ignore empty lines

        tokens = line.split("\t")
        if not len(tokens) in range(4, 7):
            raise AssertionError("Invalid interaction line: '"+line+"'")

        tokens[2] = parse_atom(tokens[2])
        tokens[3] = parse_atom(tokens[3])
        if len(tokens) >= 5:
            tokens[4] = parse_atom(tokens[4])
        if len(tokens) == 6:
            tokens[5] = parse_atom(tokens[5])
        ret.append(tuple(tokens))

    contact_file.close()

    return ret


def parse_flarelabels(label_file):
    if label_file is None:
        return None

    ret = {}
    flarelabels = set()  # Only used to check for duplicates
    for line in label_file:
        line = line.strip()
        if not line:
            continue  # Ignore empty lines

        tokens = line.split("\t")
        residentifier = tokens[0]
        flaretreepath = tokens[1] if len(tokens) > 1 else tokens[0]
        flarelabel = flaretreepath.split(".")[-1]
        flarecolor = tokens[2] if len(tokens) > 2 else "white"
        if residentifier in ret:
            raise AssertionError("Residue identifier '"+residentifier+"' appears twice in "+label_file.name)
        if flarelabel in flarelabels:
            raise AssertionError("Flare label '"+flarelabel+"' used twice in "+label_file.name)

        ret[residentifier] = {"label": flarelabel, "treepath": flaretreepath, "color": flarecolor}
        flarelabels.add(flarelabel)

    return ret


def create_graph(contacts, resi_labels):
    ret = {
        "edges": []
    }

    # Strip atom3, atom4, and atom names
    # unique_chains = set([c[2][0] for c in contacts] + [c[3][0] for c in contacts])
    contacts = [(c[0], c[1], c[2][0:3], c[3][0:3]) for c in contacts]

    resi_edges = {}
    for contact in contacts:
        # Compose a key for atom1 and atom2 that ignores the order of residues
        a1_key = ":".join(contact[2][0:3])
        a2_key = ":".join(contact[3][0:3])
        if a1_key > a2_key:
            a1_key, a2_key = a2_key, a1_key
        contact_key = a1_key + a2_key

        # Look up labels
        a1_label = a1_key if resi_labels is None else resi_labels[a1_key]["label"]
        a2_label = a2_key if resi_labels is None else resi_labels[a2_key]["label"]
        if a1_label is None or a2_label is None:
            print("Omitting contact "+str(contact)+" as it doesn't appear in flare-label file")
            continue

        # Create contact_key if it doesn't exist
        if not contact_key in resi_edges:
            edge = {"name1": a1_label, "name2": a2_label, "frames": []}
            resi_edges[contact_key] = edge
            ret["edges"].append(edge)

        resi_edges[contact_key]["frames"].append(int(contact[0]))

    # Sort edge frames and ensure that there are no duplicates
    for e in ret["edges"]:
        e["frames"] = sorted(set(e["frames"]))

    # Create "trees" and "tracks" sections if resi_labels specified
    if resi_labels is not None:
        tree = {"treeLabel": "DefaultTree", "treePaths": []}
        ret["trees"] = [tree]

        track = {"trackLabel": "DefaultTrack", "trackProperties": []}
        ret["tracks"] = [track]

        for rlabel in resi_labels.values():
            tree["treePaths"].append(rlabel["treepath"])
            track["trackProperties"].append({
                "nodeName": rlabel["label"],
                "color": rlabel["color"],
                "size": 1.0
            })

    return ret


if __name__ == "__main__":
    main()



